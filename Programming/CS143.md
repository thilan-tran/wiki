---
#YAML Frontmatter
title: "CS143: Database Systems"
subtitle: "Professor Cho"
date: "Winter 2021"
author: "Thilan Tran"
mainfont: Libertinus Serif
monofont: Iosevka
fontsize: 14pt
toc: true
documentclass: extarticle
header-includes: |
  \definecolor{Light}{HTML}{F4F4F4}
  \let\oldtexttt\texttt
  \renewcommand{\texttt}[1]{
    \colorbox{Light}{\oldtexttt{#1}}
  }
  \usepackage{fancyhdr}
  \pagestyle{fancy}
  \usepackage{amsmath}
---

\newpage{}

# CS143: Database Systems
***

- **database management system (DBMS)** is a way to manage and store data:
  - how does a database differ from a spreadsheet software like Excel?
    - expected to *efficiently* scale to a *massive* amount of data, without suffering
    - expected to persist the data
    - expected to provide secured and safe access to data
    - expected to be conveniently used by a large number of clients at a time
  - program data is not assumed to entirely reside in main memory RAM, but instead in disk
    - this leads to utilization of different data structures

- database architecture:
  1. disk for data (sometimes stored in main memory, if data can fit)
  2. OS
  3. DBMS engine
      - database system may access disk through OS, or directly through raw IO
  4. API
      - eg. standard APIs like JDBC (Java), ODBC (Microsoft)
  5. app, or CLI
  - downloading a DBMS software like MySQL installs parts 3, 4, and CLI

- popular DBMS software:
  - relational:
    - open source: MySQL, PostgreSQL
    - closed source: Oracle, Microsoft SQL, IBM DB2
  - non-relational (NoSQL):
    - MongoDB, Spark

- five steps in database construction:
  1. domain analysis
      - captured in an entity-relationship (ER) model, or with unified modeling language (UML)
  2. database design
      - normalization theory
  3. table creation
      - uses a data definition language (DDL)
  4. load
      - using SQL, or bulk load
  5. query and update
      - using data manipulation language (DML)

\newpage{}

# Data Models
***

- what is a data model? why do we need it?
  - eg. the human brain acts as a data model
    - remembers information, easily accessible and understandable data
  - how do we translate the memory of a human brain in computers?
    - computers speak in binary, only stores data in a very specific, concrete format
  - a **data model** is a very specific way to model or represent data in comptuers:

- types of data models include graph, tree, relational models:
  - a **graph model** (or network model) has nodes, edges, and labels, eg. airline flights:
    - initially most popular data model
    - more flexible and semistructured, often used for JSON data eg. MongoDB
  - a **tree model** (or hierarchical model) is a graph arranged as a tree, eg. company hierarchies
  - in a **relational model**, all data is represented as a set of tables:
    - introduced in 1970 by Codd, and completely revolutionized the database field
    - in graph and tree models, not as efficient to access and modify data:
      - intead, represent all data through relationships and store them in tables, like a spreadsheet
      - a downside to the relational model is the rigidity of its schemas
    - in mathematics, tables are expressed as **relations** eg. tuples, triplets, etc.
    - now, the most popular data model used in DBs

## Relational Models
***

- relational model terminology:
  - **relations** ie. tables contain many **tuples** ie. rows, each with various **attributes** ie. columns
  - each attribute has a **domain** ie. type
  - a **schema** is the structure of relations in a database:
    - includes properties like the relation name, attribute names, domains
    - eg. `Student(sid: int, name: str, addr: Addr, age: int, GPA: int)`
  - the **instance** is the actual data populating a relation that conforms to some schema
    - ie. schema is the variable type, and the instance is the variable value
  - **keys** are a set of attributes that *uniquely* identify a tuple in a relation:
    - multiple keys are possible
    - eg. in `Course(dept, cnum, sec, unit, instructor, title)`, the keys may be the department, course number, and section number
      - or alternatively department, section, and title if course numbers are repeated
    - generally, assuming the set of attributes for keys is the minimum set
      - in the worst case, with no duplicates, a relation's keys are all its attributes
  - more specifically, different types of keys:
    1. a **super key** is any key
    2. a **candidate key** is a key with the minimum number of attributes
    3. a **primary key** is a candidate key chosen to be used as the main key for a relation
        - shouldn't have null values
  - **null values** are used to indicate not applicable, uninitialized values, etc.:
    - are compatible with every type, unless otherwise explicitly defined
    - leads to complications, eg. comparisons in conditional queries
      - thus DBMS may return unexpected answers
    - requires **3-valued logic** where every condition can be true, false, or unknown:
      - need concrete rules to deal with null and unknown values
      - adds increased implementation and execution complexity

- name scopes of relational models:
  - the name of a relation is unique across relations
  - the names of attributes are uniue in a table
    - thought there cane be the same attribute names in different tables

- set semantics in relational models:
  - in a set, there are no duplicate elements, and order is unimportant
  - thus in the relational model:
    1. no duplicate tuples are allowed
        - but SQL allows duplicate tuples for practical reasons
    2. attribute order does not matter

\newpage{}

# Relational Algebra
***

- relational query langauges include:
  - formal languages eg. relational algebra, relational calculus, datalog
  - practical languages eg. SQL, Quel, QBE

- in relational algebra:
  - inputs and outputs are both relations, so **piping** is possible
  - set semantics are followed, so duplicates are automatically eliminated

| sid | name   | addr         | age | GPA |
|-----|--------|--------------|-----|-----|
| 301 | John   | 183 Westwood | 19  | 2.1 |
| 303 | Elaine | 301 Wilshire | 17  | 3.9 |
| 401 | James  | 183 Westwood | 17  | 3.5 |
| 208 | Esther | 421 Wilshire | 20  | 3.1 |

Table: Students \label{students}

| dept | cnum | sec | unit | title      | instructor   |
|------|------|-----|------|------------|--------------|
| CS   | 112  | 01  | 03   | Modeling   | Dick Muntz   |
| CS   | 143  | 01  | 04   | DB Systems | John Cho     |
| EE   | 143  | 01  | 03   | Signals    | Dick Muntz   |
| ME   | 183  | 02  | 05   | Mechanics  | Susan Tracey |

Table: Classes \label{classes}

| sid | dept | cnum | sec |
|-----|------|------|-----|
| 301 | CS   | 112  | 01  |
| 301 | CS   | 143  | 01  |
| 303 | EE   | 143  | 01  |
| 303 | CS   | 112  | 01  |
| 401 | CS   | 112  | 01  |

Table: Enrollments \label{enrolls}

- queries can be done using the formal relational algebra language
  - consider the following example queries using Table \ref{students}, Table \ref{classes}, and Table \ref{enrolls}

1. Get all the students:
$$Student$$
    - to get all the tuples from a relation, just write the name of the relation
2. Get all students with age $>$ 18:
$$\sigma_{age < 18} (Student)$$
    - the select operator $\sigma_C(R)$ filters based on boolean expression $C$
      - $R$ can be either a relation or a result from another operator
3. Get all students with GPA $>$ 3.7 and age $<$ 18:
$$\sigma_{gpa > 3.7 \land age < 18} (Student)$$
4. Get student ID and GPA of all students:
$$\pi_{sid, \textit{GPA}}(Student)$$
    - need a different operator
    - the project operator $\pi_A(R)$ filters column-wide based on attributes $A$
      - returns a new set of *columns*
5. Get all departments offering a class:
$$\pi_{dept}(Class)$$
    - due to set semantics, does not return two elements for "CS"
6. Get student ID and GPA of students with age $<$ 18:
$$\pi_{sid, \textit{GPA}}(\sigma_{age < 18}(Student))$$
    - composing operators next to each other
    - however, for projection, it is not useful to compose projections

- the **cross product** ie. Cartesian product operator in relational algebra:
  - $R \times S = \{ t | t = (r,s) \enskip \forall \enskip r \in R, s \in S\}$ concatenates every tuple of each relation together:
    - if $|R| = r$ and $|S| = s$, $|R \times S| = rs$
    - eg. $R \times S$ contains $a_1b_2, a_1b_2, \dots, a_nb_m$
  - ie. creates one output per every pair of input tuples
  - useful when combining tuples from multiple relations

7. Get the names of students who take CS classes:
$$\pi_{name}(\sigma_{dept = \textrm{'CS'}}(\sigma_{Student.sid = Enroll.sid}(Student \times Enroll)))$$
$$\pi_{name}(\sigma_{dept = \textrm{'CS'} \land Student.sid = Enroll.sid}(Student \times Enroll))$$
    - but this cross product is quite expensive, so we can change the ordering to improve efficiency
$$\pi_{name}(\sigma_{Student.sid = Enroll.sid}(Student \times \sigma_{dept = \textrm{'CS'}}(Enroll)))$$
    - equivalently, using the natural join operator:
$$\pi_{name}(\sigma_{dept = \textrm{'CS'}}(Student \bowtie Enroll))$$

- the **natural join** operator $\bowtie$ is used to join two tables *naturally*:
  - filters the Cartesian product by the tuples based on the equality conditions of *all* shared attributes
  - equivalent to:
$$R \bowtie S = \sigma_{\langle equal \enskip shared \enskip attributes\rangle}(R \times S)$$

| dept | cnum | sec | unit | title      | ins        | sid | dept | cnum | sec |
|------|------|-----|------|------------|------------|-----|------|------|-----|
| CS   | 112  | 01  | 03   | Modeling   | Dick Muntz | 301 | CS   | 112  | 01  |
| CS   | 112  | 01  | 03   | Modeling   | Dick Muntz | 303 | CS   | 112  | 01  |
| CS   | 112  | 01  | 03   | Modeling   | Dick Muntz | 401 | CS   | 112  | 01  |
| CS   | 143  | 01  | 03   | DB Systems | John Cho   | 301 | CS   | 143  | 01  |
| EE   | 143  | 01  | 03   | Signals    | Dick Muntz | 303 | EE   | 143  | 01  |

Table: $Class \bowtie Enroll$

8. Get the names of students who take classes offered by `'Dick Muntz'`:
$$\pi_{name}(Student \bowtie (Enroll \bowtie \sigma_{inst = \textrm{'Dick Muntz'}}(Class)))$$

9. Get the names of student pairs who live at the same address:
$$\pi_{Student.name, S.name}(\sigma_{C_1 \land C_2}(Student \times \rho_{S}(Student)))$$
    - where $C_1 = (Student.addr = S.addr)$ and $C_2 = Student.sid > S.sid$
    - crossing a relation with itself is also known as **self-join**:
      - need to use the rename operator $\rho_{S(A)}$
      - renames table to $S$ and optionally, specific attribute to $A$
    - the comparison check on `sid` prevents duplicates such as
      - `('John', 'John'), ('John', 'James'), ('James', 'John')`

10. Get all students and instructor names:
$$\pi_{name}(Student) \cup \rho_{Person(name)}(\pi_{inst}(Class))$$
    - when using union, the schema must be equal between the relations
    - ie. the attribute names have to match up
    - no duplicate tuples in the result

11. Get all the courses (department, number, section) that no one takes:
$$\pi_{dept, cnum, sec}(Class) - \pi_{dept, cnum, sec(Enroll)}$$
    - easier to express this query using its complement
    - using the set difference operator $R - S$

12. Get instructor names who teach both CS and EE courses:
$$\pi_{inst}(\sigma_{dept = \textrm{'CS'}}(Class)) \cap \pi_{isnt}(\sigma_{dept = \textrm{'EE'}}(Class))$$
    - when using intersection, the schema should again be the same
    - $R \cap S = R - (R - S)$

13. Get IDs of students who did not take any CS class:
$$\pi_{sid}(Student) - \pi_{sid}\sigma_{dept = \textrm{'CS'}}(Enroll)$$

- the core relational operators are:
  - $\sigma, \pi, \times, \cup, \rho, -$
    - set difference is the only non-monotonic operator, so it is core
  - while the other operators $\bowtie, \cap$ can be expressed with other operators

\newpage{}

# SQL
***

- **structured query language (SQL)** is the standard langauge for interacting with relational DBMS (RDBMS):
  - many versions of the SQL standard exists, SQL92 or SQL2 is the main standard
  - has multiple components:
    - the **data definition language (DDL)** includes schema definitions, constraints, etc.
      - eg. `CREATE, ALTER, DROP`
    - the **data manipulation language (DML)** includes queries, modifications, etc.
      - eg. `SELECT, INSERT, UPDATE`
    - other components for transactions and authorization

## Data Definition Language (DDL)
***

- the DDL component of SQL allows for expressing schema definitions

- basic common SQL data types:
  - string:
    - `Char(n)` with padded fixed length $n$
      - will pad shorter values
    - `Varchar(n)` with variable length and max length $n$
  - number:
    - `Integer` 32-bit
    - `Decimal(d, f)` with $d$ total digits and $f$ precision
      - eg. the max value of `Decimal(5, 2)` is `999.99`, useful for financial values
    - `Real` 32-bit, `Double` 64-bit
  - datetime:
    - `Date` eg. `2010-01-15`
      - no timezone in SQL standard!
    - `Time` eg. `13:50:00`
    - `Timestamp` eg. `2010-01-15 13:50:00`
      - on MySQL, `Datetime` is preferred instead

- SQL table creation:
  - `CREATE TABLE` statement
  - one `PRIMARY KEY` per table:
    - `UNIQUE` is used for other keys (attributes may be null by SQL92)
    - by SQL standard, primary keys cannot be null
      - system will automatically mark those keys as not null, though the standard requires it to be explicitly written
  - `DEFAULT` sets the default value for an attribute
  - `DROP TABLE` statement for deleting a table

SQL table creation example:
```sql
CREATE TABLE Course(
  dept CHAR(2) NOT NULL DEFAULT 'CS',
  cnum INTEGER NOT NULL,
  sec  INTEGER NOT NULL,
  unit INT,
  instructor VARCHAR(50),
  title      VARCHAR(100),
  PRIMARY KEY(dept, cnum, sec),
  UNIQUE(dept, sec, title)
);
```
## Loading Data
***

- there is no SQL standard for bulk data loading:
  - in Oracle and MySQL, `LOAD DATA INFILE <file> INTO TABLE <table>`

- options:
  - comma vs. tab separation for columns
    - `FIELDS TERMINATED BY ','`
  - columns enclosed with quotes
    - `OPTIONALLY ENCLOSED BY '"'`

## Database Manipulation Language (DML)
***

- SQL gives a high-level description of what a user wants:
  - given a SQL query, DBMS figures out how best to execute it *automatically*
  - the core query operators are selection, projection, and join (SPJ)

The following is the full general format for SQL `SELECT`:
```sql
SELECT attributes, aggregates
FROM relations
WHERE conditions
GROUP BY attributes
HAVING aggregate condition
ORDER BY attributes
FETCH FIRST n ROWS ONLY
```
- note that `SELECT` appears first, but is the last clause to be interpreted
    - all other clauses can be semantically interpreted as executed in order

### Relational Algebra Analogs

- consider the following example queries using Table \ref{students}, Table \ref{classes}, and Table \ref{enrolls}

1. Get the titles and instructors of all CS classes:
```sql
SELECT title, instructor -- project in SELECT clause
FROM Class               -- specify relations in FROM clause
WHERE dept='CS';         -- filter through condition in WHERE clause
```
- thus, the SQL statement `SELECT A1...An FROM R1...Rm WHERE C` is roughly equivalent to:
  - $\pi_{A_1 \dots A_n}(\sigma_C(R_1 \times \dots \times R_m))$
  - differences:
    - `SELECT` is projection rather than selection
    - SQL *does not* remove duplicates, uses *multiset* ie. bag semantics instead
        - sets can have duplicate elements and $\{a,b,a\} \neq \{a, b\}$

- multiset semantics and equivalence relation differences:
    - $R \cup S = S \cup R$ and $R \cap S = S \cap R$
    - but $R \cap (S \cap T) \neq (R\cap S)\cup (R\cap T)$

2. Get the names and GPAs of all students who take CS classes:
```sql
SELECT name, GPA AS grade -- renaming attributes, AS optional
FROM Student S, Enroll E  -- renaming operator for tuples, ie. tuple variables
WHERE dept='CS' AND S.sid=E.sid;

-- this returns duplicates if a student takes multiple classes!
SELECT DISTINCT name, GPA -- DISTINCT removes duplicates on final projected output
...
```
3. Get all student names and GPAs who live on Wilshire:
```sql
SELECT name, gpa
FROM Student
WHERE address = '%Wilshire%';
```
- string variables:
  - `%` for any length string, `_` for a single character
  - eg. `%Wilshire%` matches any string containing `Wilshire`
  - eg. `___%` matches any string with length $\geq 3$
- other string functions include `UPPER(), LOWER(), CONCAT()`

4. Get all student and instructor names:
```sql
(SELECT name
FROM Student)
UNION -- set operator automatically takes care of duplicate instructors
(SELECT instructor -- can optionally rename to match input schemas
FROM Class);
```
- set operators:
  - eg. `UNION, INTERSECT, EXCEPT`
  - these operators *do* follow set semantics and remove duplicates
  - schemas of input relations should be the same
    - in practice, compatible types are fine
- to keep duplicates use `UNION ALL` etc. to enable bag semantics:
    - $\{a,a,b\} \cup \{a,b,c\} = \{a,a,a,b,b,c\}$
    - $\{a,a,a,b,c\} \cap \{a,a,c\} = \{a,a,b\}$
    - $\{a,a,b,b\} - \{a,b,b,c\} = \{a\}$

5. Get all SIDs of students who do not take any cs class
```sql
(SELECT sid FROM Student)
EXCEPT
(SELECT sid FROM Enroll WHERE dept='CS');
```
## Subqueries
***

- SQL has extensions that allow certain queries that can not be expressed using purely relational algebra eg. subqueries and aggregate queries

- a SQL **subquery** is a nested `SELECT` statement within another:
  - the result from the inner `SELECT` is treated like a regular relation
  - if the result is a single-attribute, single-tuple relation, the result can also be used as a constant value ie. a **scalar-valued subquery**

- consider the following example queries using Table \ref{students}, Table \ref{classes}, and Table \ref{enrolls}

1. Get SIDs of students who live sith student 301:
```sql
SELECT sid
FROM Student
WHERE addr=(SELECT addr FROM Student WHERE sid=301)
      AND sid<>301;

-- without using subqueries:
SELECT S2.sid
FROM Student S1, Student S2
WHERE S1.addr=S2.addr AND S1.sid<>S2.sid AND S1.sid=301;
```
- using a scalar-valuled subquery
  - can not always guarantee that the subquery is a scalar, but filtering on the primary key does guarantees the result is a single tuple

- if we can always rewrite subqueries in a non-subquery systems, the two would be expressively equivalent:
  - generally, we can rewrite subqueries to non-subqueries as long as there is no negation
    - with negation, need to use `EXCEPT`
  - thus does not lend extra expressive power to SQL
    - ie. is a syntactic sugar for SQL

2. Get student names who take CS classes:
```sql
SELECT name
FROM Student
WHERE sid IN (SELECT sid FROM Enroll WHERE dept='CS');

-- without using subqueries:
SELECT DISTINCT name -- without DISTINCT, would return duplicates
FROM Student S, Enroll E
WHERE S.sid=E.sid AND dept='CS';
```
- the `IN` keyword is the set membership operator ie. $a \in S$:
  - note that in the example, the set may be a multiset operator, but `IN` would still does not return duplicates

3. Get student names who take no CS classes:
```SQL
SELECT name
FROM Student
WHERE sid NOT IN (SELECT sid FROM Enroll WHERE dept='CS');

-- without using subqueries:
(SELECT name FROM Student)
EXCEPT
(SELECT name
FROM Student S, Enroll E
WHERE S.sid=E.sid AND dept='CS');
```
4. Get student IDs who have higher GPA than any student of age 18 or less:
```sql
SELECT sid
FROM Student
WHERE GPA>ALL( SELECT GPA FROM Student WHERE age<=18);
```
- `ALL, SOME` are set comparison operators that compares a value against an entire set of values:
  - eg. `a>ALL R`, `a<=SOME R`
  - note that `= SOME` is equivalent to `IN` and `<> ALL` is equivalent to `NOT IN`

5. Get student names who take any class:
```sql
SELECT name
FROM Student
WHERE sid IN (SELECT sid FROM Enroll);

-- using a correlated subquery to reference an outer relation
SELECT name
FROM Student S
WHERE EXISTS(SELECT * FROM Enroll E WHERE E.sid=S.sid);
```
- conceptually, for **correlated subqueries** to reference outer relations:
  - outer query looks at one tuple at a time and bids the tuple to `S`
  - for each `S` we execute the inner query and check the condition
  - real DBMS executes it more efficiently
- `EXISTS R` is true if `R` is a single query

- subqueries can also appear inside a `FROM` statement, but they *must* be renamed
  - eg. `... FROM (SELECT name, age FROM Student) S ...`

- a **common table expression** can be used to alias a subquery
  - convenient for using the result of the same subquery multiple times

Example using aliases:
```sql
WITH S AS (SELECT name, age FROM Student)
SELECT name FROM S WHERE AGE > 17;
```
## Aggregates
***

- an **aggregate function** is a *new* mechanism to combine information from multiple input tuples into a single output tuple:
  - rather than getting information from one input tuple per output
  - eg. `AVG, SUM, COUNT, MIN, MAX`
  - thus aggregates *do* increase the expressiveness of SQL compared to relational algebra

- consider the following example queries using Table \ref{students}, Table \ref{classes}, and Table \ref{enrolls}

1. Get average GPA of all students:
```sql
SELECT AVG(gpa)
FROM Student;
```
2. Get number of students taken CS classes:
```sql
SELECT COUNT(DISTINCT sid) -- need to avoid duplicates
-- SELECT DISTINCT COUNT(sid) is incorrect!
FROM Enroll
WHERE dept='CS';
```
3. Get average GPA of students who take CS classes:
```sql
-- incorrect, averages duplicate GPAs
SELECT AVG(GPA)
FROM Enroll E, Student S
WHERE E.sid=S.sid AND dept='cs';

-- subqueries are useful for handling duplicates
SELECT AVG(GPA)
FROM Student
WHERE sid IN (SELECT sid FROM Enroll WHERE dept='cs');
```
4. Get average GPA for each age group:
```sql
SELECT age, AVG(GPA)
-- SELECT sid, age, AVG(GPA) fails because an age group does not have the same sid
FROM Student
GROUP BY age;
```
- the `GROUP BY` operator partitions the groups that the aggregate function performs on
  - with `GROUP BY`, `SELECT` can have only aggregate functions or attributes that have a *single* value in each group

5. Get number of classes each student takes:
```sql
SELECT sid, COUNT(*)
FROM Enroll
GROUP BY sid;
-- this skips students who take no classes!
-- need to perform a union with those students, or use another technique
```
6. Get students who take two or more classes:
```sql
SELECT sid
FROM Enroll
-- WHERE COUNT(*)>=2 fails, aggregate cannot appear as part of WHERE
GROUP BY sid
HAVING COUNT(*)>=2;
```
- the `HAVING` clause is used to check on the condition of an aggregate
  - appears after `GROUP BY`

## More SQL Extensions
***

- consider the following example queries using Table \ref{students}, Table \ref{classes}, and Table \ref{enrolls}

1. For each student, return their name, GPA, and the *overall* GPA average:
```sql
SELECT name, GPA, AVG(GPA) FROM Student;
-- is an error, using attribute names in an aggregate
-- that are not unique over the *entire* group

SELECT name, GPA, AVG(GPA) FROM Student GROUP BY sid;
-- does not give an error, but AVG(GPA) is the incorrect value

SELECT name, GPA, AVG(GPA) OVER() FROM Student;
```
- the `OVER()` function is the SQL **window function**, used after some aggregate `FUNCTION(attr)`
    - generates one output tuple per input tuple, but the function is computed over *all* input tupless

2. For each student, return their name, GPA, and the average GPA in their age group:
```sql
SELECT name, GPA, AVG(GPA) OVER(PARTITION BY AGE) FROM Student;
```
- the `PARTITION` clause applies the window function over a specific grouping:
    - analagous to `GROUP BY` for the aggregate function
    - ie. changing the window over which the parent aggregate function is computed

3. Order students by GPA:
```sql
ORDER BY GPA DESC, sid ASC; -- primary ordering GPA, secondary ordering SID
```
- since SQL is based on multiset semantics, tuple order is ignored:
    - but for presentation purposes, the `ORDER BY` clause orders the result tuples by certain attributes
    - the default ordering direction is `ASC` if omitted
    - note that this not change SQL semantics and is purely for presentation

4. Get top 3 students order by GPA:
```sql
SELECT * FROM Students
ORDER BY GPA DESC
FETCH FIRST 3 ROWS ONLY;
```
- can limit the number of returned tuples with the `FETCH` clause:
    - `[OFFSET <num> ROWS] FETCH FIRST <count> ROWS ONLY`
    - skip the first `num` tuples and return the subsequent `count` rows
    - this was standardized too late, MySQL variation is `LIMIT <count> OFFSET <num>`

- note that with all of its expressiveness, SQL is *not* a Turing-complete language
    - relatively simple extension to make it TC, just have to allow for user-defined aggregate functions

## Handling `NULL`
***

What will be returned from the following query if GPA is `NULL`?
```sql
SELECT name FROM Student WHERE GPA * 100/4 > 90
```
- SQL is based on **three-valued logic**:
    - all conditions are evaluated to be `True, False, Unknown`
    - if input to an arithmetic operator is `NULL`, its output is `NULL`
    - arithmetic comparison with `NULL` then returns `Unknown`
        - eg. `NULL > 90`
    - SQL returns a tuple only if the result from condition is `True`
    - note that `NOT Unknown` is still `Unknown`

- assume GPA is `NULL` and age is 17:
    - `GPA > 3.7 AND age > 18` gives `Unknown AND False` which evaluates to `False`
        - `AND` short-circuits
    - `GPA > 3.7 OR age > 18` gives `Unknown OR False` which evaluates to `Unknown`

| `AND, OR` | True        | False        | Unknown        |
|-----------|-------------|--------------|----------------|
| True      | True, True  | False, True  | Unknown, True  |
| False     | False, True | False, False | False, Unknown |

Table: Truth Table for Three-Valued Logic

| sid | GPA    |
|-----|--------|
| 1   | 3.0    |
| 2   | 3.6    |
| 3   | 2.4    |
| 4   | `NULL` |

Table: Example for Aggregates \label{nullaggr}

- handling null values in aggregates from Table \ref{nullaggr}:
    - SQL aggregates ignore null values and apply the aggregate on the remaining tuples
    - `SELECT SUM(GPA) FROM Student` gives 9.0
        - in theory `Unknown` would be more valid
    - `SELECT AVG(GPA) FROM Student` gives 3.0
    - `SELECT COUNT(GPA) FROM Student` gives 3
    - `SELECT COUNT(*) FROM Student` gives 4
        - `COUNT(*)` is the exception that also counts tuples that might have null values everywhere
    - when an input to an aggregate function is *empty*:
        - `COUNT()` returns 0
        - all other aggregates return `NULL`

- handling null values in set operators:
    - eg. $\{2.4, 3.0, null\} \cup \{3.6, null\} = \{2.4, 3.0, 3.6, null\}$
    - `NULL` is treated like regular values for set operators
    - to checking `NULL`, can use `IS NULL` or `IS NOT NULL`:
        - note that `= NULL` and `<> NULL` do *not* work to check `NULL`
        - `= NULL` evaluates to `Unknown`

Ex. Get the number of classes each student takes, including 0-class students:
```sql
SELECT sid, COUNT(*)
FROM Enroll
GROUP BY sid;
-- this does not return 0-class students!

SELECT sid, COUNT(*)
FROM Student S, Enroll E
WHERE S.sid=E.sid
GROUP BY sid;
-- still does not return 0-class students!

SELECT sid, COUNT(cnum) -- CANNOT use COUNT(*) since it will count the null cnum as 1
FROM Student S LEFT OUTER JOIN Enroll E ON S.sid=E.sid
GROUP BY sid;
```
- in this example, students taking no classes become **dangling tuple**
    - these tuples do not get preserved in the join condition
- need to use the **outer join** function to preserve dangling tuples:
    - `<relation1> <dir> OUTER JOIN <relation2> ON <condition>`
        - can perform a `LEFT OUTER JOIN`, `RIGHT OUTER JOIN`, `FULL OUTER JOIN`
    - remaining attributes that are supposed to come from the other side are set as `NULL`

## Data Modification
***

- the `INSERT` statement inserts a new tuple:
  - `INSERT INTO <relation> <tuples>`
  - `VALUES` keyword is used to literally specify tuples
- the `DELETE` statement removes tuples:
  - `DELETE FROM <relation> WHERE <condition>`
- the `UPDATE` statement updates tuples attributes:
  - `UPDATE <relation> SET <a1> = <v1>, ... WHERE <condition>`

1. Insert new tuples into the `Enroll` table:
```sql
INSERT INTO Enroll VALUES (301,'CS',201,1), (420,'EE',401,2);
```
2. Populate `Honors` table with students of GPA $>$ 3.7:
```sql
INSERT INTO Honors (SELECT * FROM Student WHERE gpa>3.7);
```
3. Delete all students who are not taking classes:
```sql
DELETE FROM Student
WHERE sid NOT IN (SELECT sid FROM ENROLL);
```
4. Increase all CS course numbers by 100:
```sql
UPDATE Class
SET cnum=cnum+100
WHERE dept='CS';
```
